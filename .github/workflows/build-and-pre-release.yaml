name: Build and Pre-release

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  check-trigger:
    runs-on: ubuntu-latest
    name: Check if build should trigger
    outputs:
      should-build: ${{ steps.check.outputs.should-build }}
    steps:
      - name: Check commit message or PR title
        id: check
        run: |
          SHOULD_BUILD="false"

          # Check commit message for push events
          if [ "${{ github.event_name }}" = "push" ]; then
            COMMIT_MESSAGE="${{ github.event.head_commit.message }}"
            echo "Commit message: $COMMIT_MESSAGE"
            if [[ "$COMMIT_MESSAGE" =~ ^BUILD.* ]]; then
              SHOULD_BUILD="true"
              echo "✅ Commit message starts with BUILD"
            else
              echo "❌ Commit message does not start with BUILD"
            fi
          fi

          # Check PR title for pull request events
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            PR_TITLE="${{ github.event.pull_request.title }}"
            echo "PR title: $PR_TITLE"
            if [[ "$PR_TITLE" =~ ^BUILD.* ]]; then
              SHOULD_BUILD="true"
              echo "✅ PR title starts with BUILD"
            else
              echo "❌ PR title does not start with BUILD"
            fi
          fi

          # Always build on manual trigger
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            SHOULD_BUILD="true"
            echo "✅ Manual workflow trigger - building"
          fi

          echo "should-build=$SHOULD_BUILD" >> $GITHUB_OUTPUT
          echo "Final decision: should-build=$SHOULD_BUILD"

  generate-version:
    runs-on: ubuntu-latest
    needs: check-trigger
    if: needs.check-trigger.outputs.should-build == 'true'
    name: Generate Version
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      summary: ${{ steps.summary.outputs.summary }}

    steps:
      - name: Checkout source code
        uses: actions/checkout@v5

      - name: Extract project version and generate incremental version
        id: version
        run: |
          # Read base version from version.txt instead of parsing YAML
          if [ ! -f version.txt ]; then
            echo "version.txt not found" >&2
            exit 1
          fi
          BASE_VERSION=$(sed -n '1{s/\r$//;p}' version.txt | tr -d ' ') 
          if [ -z "$BASE_VERSION" ]; then
            echo "version.txt is empty" >&2
            exit 1
          fi
          echo "Base version (from version.txt): $BASE_VERSION"

          # Fetch tags
          git fetch --tags || true

          LATEST_TAG=$(git tag -l "$BASE_VERSION.*" | sort -V | tail -1 || echo "")

          LATEST_VERSION="$LATEST_TAG"

          if [ -z "$LATEST_VERSION" ]; then
            INCREMENTAL_VERSION="${BASE_VERSION}.0"
          else
            CURRENT_INCREMENT=$(echo "$LATEST_VERSION" | sed "s/${BASE_VERSION}\.//")
            NEXT_INCREMENT=$((CURRENT_INCREMENT + 1))
            INCREMENTAL_VERSION="${BASE_VERSION}.${NEXT_INCREMENT}"
          fi

          TAG="$INCREMENTAL_VERSION"
          echo "version=$INCREMENTAL_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Base version: $BASE_VERSION"
          echo "Full version: $INCREMENTAL_VERSION"
          echo "Release tag: $TAG"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate release summary from CHANGELOG
        id: summary
        run: |
          set -euo pipefail
          VERSION='${{ steps.version.outputs.version }}'
          BASE_MAJOR_MINOR="${VERSION%.*}"   # e.g. 2025.2 from 2025.2.0
          INCREMENT="${VERSION##*.}"        # last segment
          echo "Searching for version: $VERSION (base: $BASE_MAJOR_MINOR, increment: $INCREMENT)"
          if [ ! -f CHANGELOG.md ]; then
            echo "summary=# $VERSION" >> $GITHUB_OUTPUT
            exit 0
          fi
          # Use literal matching instead of regex for better reliability
          awk -v base_ver="$BASE_MAJOR_MINOR" -v inc="$INCREMENT" -v ver="$VERSION" '
          BEGIN{foundMM=0;foundInc=0} 
          {
            # Match major.minor header exactly
            if ($0 == "# " base_ver) {
              foundMM=1
              print "Found major.minor header: " $0 > "/dev/stderr"
              next
            }
            # Exit if we hit another major header
            if (foundMM && $0 ~ /^# / && $0 != "# " base_ver) {
              print "Hit new major header, exiting: " $0 > "/dev/stderr"
              exit
            }
            # Match increment header exactly  
            if (foundMM && $0 == "## ." inc) {
              foundInc=1
              print "Found increment header: " $0 > "/dev/stderr"
              next
            }
            # Process content in increment section
            if (foundInc) {
              if ($0 ~ /^## /) {
                print "Hit new increment header, stopping: " $0 > "/dev/stderr"
                foundInc=0
                next
              }
              if ($0 ~ /^# /) {
                print "Hit new major header, exiting: " $0 > "/dev/stderr"
                exit
              }
              if ($0 ~ /^-/) {
                print "Adding line: " $0 > "/dev/stderr"
                print $0
              }
            }
          }' CHANGELOG.md > /tmp/summary.txt
          if [ -s /tmp/summary.txt ]; then
            # Create formatted summary with version header and preserve list structure
            echo "# $VERSION" > /tmp/formatted_summary.txt
            cat /tmp/summary.txt >> /tmp/formatted_summary.txt
            # Create proper JSON with \r\n sequences using printf to generate actual escape sequences
            SUMMARY=""
            first_line=true
            while IFS= read -r line; do
              escaped_line=$(echo "$line" | sed 's/%/%25/g')
              if [ "$first_line" = true ]; then
                SUMMARY="$escaped_line"
                first_line=false
              else
                # Use printf to create actual \r\n escape sequences
                SUMMARY="$SUMMARY$(printf '\r\n')$escaped_line"
              fi
            done < /tmp/formatted_summary.txt
            echo "Summary extracted with header:"
            cat /tmp/formatted_summary.txt
            echo "summary=$SUMMARY" >> $GITHUB_OUTPUT
          else
            echo "No matching changelog entries found for $VERSION; fallback to version header only"
            echo "summary=# $VERSION" >> $GITHUB_OUTPUT
          fi

  build-firmware:
    name: Build Firmware
    needs: [check-trigger, generate-version]
    if: needs.check-trigger.outputs.should-build == 'true'
    uses: DoYouHost/workflows/.github/workflows/build.yml@main
    with:
      files: |
        serverCoolingFanController.yaml
      esphome-version: "2025.8.2"
      combined-name: ServerCoolingFanController
      release-version: ${{ needs.generate-version.outputs.version }}
      release-summary: ${{ needs.generate-version.outputs.summary }}
      release-url: "https://github.com/DoYouHost/ServerCoolingFanController/releases/tag/${{ needs.generate-version.outputs.tag }}"
      debug: false

  upload-to-pre-release:
    name: Upload to Pre-Release
    uses: DoYouHost/workflows/.github/workflows/upload-to-gh-release.yml@main
    needs:
      - build-firmware
      - generate-version
    with:
      version: ${{ needs.generate-version.outputs.version }}
      description: ${{ needs.generate-version.outputs.summary }}
      prerelease: true
    secrets:
      PAT_TOKEN: ${{ secrets.DOYOUHOST_PAT }}

  upload-to-r2:
    name: Upload to R2
    uses: DoYouHost/workflows/.github/workflows/upload-to-r2.yml@main
    needs:
      - build-firmware
      - generate-version
    with:
      directory: serverCoolingFanController
    secrets: inherit

  promote-to-beta:
    name: Promote to Beta
    uses: DoYouHost/workflows/.github/workflows/promote-r2.yml@main
    needs:
      - build-firmware
      - generate-version
      - upload-to-r2
    with:
      version: ${{ needs.generate-version.outputs.version }}
      directory: serverCoolingFanController
      channel: beta
      manifest-filename: manifest-beta.json
    secrets: inherit
