---
substitutions:
  API_KEY: "Zeikx9TPIaEuYCmaC4EgAf93MsP946vpPf0hzGjFdM0="
  OTA_PASSWORD: "dZDYhrmYcxn_M7ih0@_W9r5jbbkaD4gk"
  DS18B20_1_ADDRESS: "0x1b3c44e3817b6e28"
  DS18B20_2_ADDRESS: "0xc63a904d1f64ff28"
  PROD_MANIFEST_URL: "https://morganmlg.com/serverCoolingFanController/manifest.json"
  BETA_MANIFEST_URL: "https://morganmlg.com/serverCoolingFanController/manifest-beta.json"
  WEB_USERNAME: "esphome"
  WEB_PASSWORD: "esphome"

esphome:
  name: server-cooling-fan
  friendly_name: "Server Cooling Fan"
  comment: "WT32-ETH01 fan controller with temperature sensors"
  name_add_mac_suffix: true
  project:
    name: "DoYouHost.ServerCoolingFanController"
    version: "dev"
  on_boot:
    priority: -100
    then:
      - lambda: |-
          ESP_LOGI("main", "Checking fan states after boot...");
          
          if (id(cabinet_fan).state) {
            ESP_LOGI("main", "Cabinet fan was restored as ON - starting safe start sequence");
            int restored_speed = id(cabinet_fan).speed > 0 ? id(cabinet_fan).speed : 1;
            id(cabinet_fan_safe_start)->execute(restored_speed);
          }

esp32:
  board: esp32dev
  framework:
    type: esp-idf
    version: recommended

globals:
  - id: cabinet_fan_commanded
    type: bool
    initial_value: 'false'
  - id: rack_fan_commanded
    type: bool
    initial_value: 'false'
  - id: cabinet_fan_error_count
    type: int
    initial_value: '0'
  - id: rack_fan_error_count
    type: int
    initial_value: '0'
  - id: cabinet_fan_runtime_hours
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: rack_fan_runtime_hours
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: cabinet_fan_spin_up_active
    type: bool
    initial_value: 'false'
  - id: cabinet_fan_target_speed
    type: int
    initial_value: '0'
  - id: cabinet_fan_saved_state
    type: bool
    initial_value: 'false'
  - id: rack_fan_saved_state
    type: bool
    initial_value: 'false'
  - id: cabinet_fan_saved_speed
    type: int
    initial_value: '0'
  - id: rack_fan_saved_speed
    type: int
    initial_value: '0'
  - id: cabinet_fan_temps
    type: std::vector<float>
    restore_value: false
  - id: cabinet_fan_speeds
    type: std::vector<int>
    restore_value: false
  - id: rack_fan_temps
    type: std::vector<float>
    restore_value: false
  - id: rack_fan_speeds
    type: std::vector<int>
    restore_value: false
  - id: cabinet_curve_loaded
    type: bool
    initial_value: 'false'
  - id: rack_curve_loaded
    type: bool
    initial_value: 'false'
  - id: fan_curves_downloaded
    type: bool
    initial_value: 'false'

ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk:
    pin: GPIO0
    mode: CLK_EXT_IN
  phy_addr: 1
  power_pin: GPIO16

debug:
  update_interval: 5s

logger:
  level: DEBUG
  logs:
    pulse_counter: INFO

safe_mode:

api:
  reboot_timeout: 30min
  batch_delay: 50ms
  encryption:
    key: "$API_KEY"

http_request:
  follow_redirects: true

ota:
  - platform: esphome
    password: "$OTA_PASSWORD"
  - platform: http_request

update:
  - platform: http_request
    id: update_http_request
    name: Firmware Update
    source: $PROD_MANIFEST_URL

web_server:
  port: 80
  version: 3
  include_internal: true
  local: true
  auth:
    username: "$WEB_USERNAME"
    password: "$WEB_PASSWORD"

one_wire:
  - platform: gpio
    pin: GPIO4

i2c:
  sda: GPIO14
  scl: GPIO15
  scan: true
  id: bus_a

pcf8574:
  - id: pcf8574_hub
    address: 0x20
    pcf8575: false

time:
  - platform: homeassistant
    id: homeassistant_time

interval:
  - interval: 5s
    then:
      - lambda: |-
          int required_cycles = (int)(id(failure_detection_after).state / 5.0);
          if (required_cycles < 1) required_cycles = 1;
          
          // Cabinet fan
          bool cabinet_running = id(cabinet_fan).state;
          id(cabinet_fan_commanded) = cabinet_running;

          if (cabinet_running) {
            // Increment runtime hours (5 seconds = 5/3600 hours)
            id(cabinet_fan_runtime_hours) += (5.0 / 3600.0);

            if (id(cabinet_fan_tach).state == 0 ||
                id(cabinet_fan2_tach).state == 0) {
              id(cabinet_fan_error_count) += 1;
            } else {
              id(cabinet_fan_error_count) = 0; // Reset counter if working
            }
          } else {
            id(cabinet_fan_error_count) = 0; // Reset when fan is off
          }

          // Rack fan
          bool rack_running = id(rack_fan).state;
          id(rack_fan_commanded) = rack_running;

          if (rack_running) {
            // Increment runtime hours (5 seconds = 5/3600 hours)
            id(rack_fan_runtime_hours) += (5.0 / 3600.0);

            if (id(rack_fan_tach).state == 0 || id(rack_fan2_tach).state == 0) {
              id(rack_fan_error_count) += 1;
            } else {
              id(rack_fan_error_count) = 0; // Reset counter if fans are working
            }
          } else {
            id(rack_fan_error_count) = 0; // Reset when fan is off
          }

text_sensor:
  - platform: version
    name: ESPHome Version
    entity_category: "diagnostic"

  - platform: ethernet_info
    ip_address:
      entity_category: "diagnostic"
      name: IP Address
    dns_address:
      entity_category: "diagnostic"
      name: DNS Address
    mac_address:
      entity_category: "diagnostic"
      name: MAC Address

  - platform: template
    id: fan_error_explanation
    name: "Fan Error Details"
    lambda: |-
      std::string error_msg = "No errors";
      bool has_error = false;
      
      int required_cycles = (int)(id(failure_detection_after).state / 5.0);
      if (required_cycles < 1) required_cycles = 1;

      // Cabinet fans
      if (id(cabinet_fan_commanded) &&
          id(cabinet_fan_error_count) >= required_cycles) {
        if (id(cabinet_fan_tach).state == 0) {
          error_msg = has_error ? error_msg + ", Cabinet Fan 1 not responding" :
                      "Cabinet Fan 1 not responding";
          has_error = true;
        }
        if (id(cabinet_fan2_tach).state == 0) {
          error_msg = has_error ? error_msg + ", Cabinet Fan 2 not responding" :
                      "Cabinet Fan 2 not responding";
          has_error = true;
        }
      }

      // Rack fans
      if (id(rack_fan_commanded) &&
          id(rack_fan_error_count) >= required_cycles) {
        if (id(rack_fan_tach).state == 0) {
          error_msg = has_error ? error_msg + ", Rack Fan 1 not responding" :
                      "Rack Fan 1 not responding";
          has_error = true;
        }
        if (id(rack_fan2_tach).state == 0) {
          error_msg = has_error ? error_msg + ", Rack Fan 2 not responding" :
                      "Rack Fan 2 not responding";
          has_error = true;
        }
      }

      return error_msg;
    update_interval: 5s

  - platform: template
    id: fan_curves_status
    name: "Fan Curves Status"
    entity_category: "diagnostic"
    lambda: |-
      std::string status = "";
      
      if (id(cabinet_curve_loaded)) {
        status += "Cabinet: " + std::to_string(id(cabinet_fan_temps).size()) + " points [";
        for (size_t i = 0; i < id(cabinet_fan_temps).size(); i++) {
          if (i > 0) status += ", ";
          status += std::to_string((int)id(cabinet_fan_temps)[i]) + "°C:" + std::to_string(id(cabinet_fan_speeds)[i] * 10) + "%";
        }
        status += "]";
      } else {
        status += "Cabinet: Not loaded";
      }
      
      status += " | ";
      
      if (id(rack_curve_loaded)) {
        status += "Rack: " + std::to_string(id(rack_fan_temps).size()) + " points [";
        for (size_t i = 0; i < id(rack_fan_temps).size(); i++) {
          if (i > 0) status += ", ";
          status += std::to_string((int)id(rack_fan_temps)[i]) + "°C:" + std::to_string(id(rack_fan_speeds)[i] * 10) + "%";
        }
        status += "]";
      } else {
        status += "Rack: Not loaded";
      }
      
      return status;
    update_interval: 60s

binary_sensor:
  - platform: status
    id: esp_status
    name: Status
    device_class: connectivity
    on_state:
      then:
        - if:
            condition:
              lambda: return x == true && !id(fan_curves_downloaded);
            then:
              - delay: 5s
              - script.execute: download_fan_curves

  - platform: gpio
    id: manual_override_button
    name: "Manual Override Button"
    pin:
      number: GPIO39
      inverted: true
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      then:
        - lambda: |-
            id(cabinet_fan_saved_state) = id(cabinet_fan).state;
            id(rack_fan_saved_state) = id(rack_fan).state;
            id(cabinet_fan_saved_speed) = id(cabinet_fan).speed;
            id(rack_fan_saved_speed) = id(rack_fan).speed;
        - fan.turn_on:
            id: cabinet_fan
            speed: 10
        - fan.turn_on:
            id: rack_fan
            speed: 10
        - logger.log: "Manual override activated - fans at full speed, states saved"
    on_release:
      then:
        - lambda: |-
            if (id(cabinet_fan_saved_state)) {
              auto call = id(cabinet_fan).make_call();
              call.set_speed(id(cabinet_fan_saved_speed));
              call.perform();
            } else {
              id(cabinet_fan).turn_off().perform();
            }
            
            if (id(rack_fan_saved_state)) {
              auto call = id(rack_fan).make_call();
              call.set_speed(id(rack_fan_saved_speed));
              call.perform();
            } else {
              id(rack_fan).turn_off().perform();
            }
        - logger.log: "Manual override released - fans restored to previous state"

  - platform: template
    id: fan_error
    name: "Fan Error"
    device_class: problem
    lambda: |-
      // Calculate required error cycles based on failure detection time
      int required_cycles = (int)(id(failure_detection_after).state / 5.0);
      if (required_cycles < 1) required_cycles = 1;
      
      return (id(cabinet_fan_error_count) >= required_cycles) ||
             (id(rack_fan_error_count) >= required_cycles);
    on_state:
      then:
        - lambda: |-
            if (x) {
              id(my_display).show_page(id(error_page));
              id(error_led).turn_on().set_effect("Error Strobe").perform();
            } else {
              id(my_display).show_page(id(normal_page));
              id(error_led).turn_off().perform();
            }
        - component.update: my_display

sensor:
  - platform: uptime
    name: Uptime
    update_interval: 60s
    accuracy_decimals: 0
    icon: mdi:clock-outline
    entity_category: "diagnostic"

  - platform: debug
    loop_time:
      name: "Loop Time"
    cpu_frequency:
      name: "CPU Frequency"
      unit_of_measurement: "MHz"
      filters:
        - multiply: 0.000001

  - platform: internal_temperature
    id: internal_temp
    name: "Internal Temperature"
    update_interval: 60s

  - platform: dallas_temp
    id: cabinet_temp
    address: $DS18B20_1_ADDRESS
    name: "Cabinet Temperature"
    update_interval: 5s
    accuracy_decimals: 1
    icon: mdi:thermometer
    filters:
      - throttle_with_priority:
          timeout: 30s
          value:
            - nan

  - platform: dallas_temp
    id: rack_temp
    address: $DS18B20_2_ADDRESS
    name: "Rack Temperature"
    update_interval: 5s
    accuracy_decimals: 1
    icon: mdi:thermometer
    filters:
      - throttle_with_priority:
          timeout: 30s
          value:
            - nan

  - platform: pulse_counter
    id: cabinet_fan_tach
    name: "Cabinet Fan RPM"
    pin:
      number: GPIO32
      mode:
        input: true
        pullup: false
    count_mode:
      rising_edge: INCREMENT
      falling_edge: DISABLE
    update_interval: 1s
    filters:
      - multiply: 0.5
      - throttle_with_priority:
          timeout: 3s
          value:
            - nan
            - 0
      - clamp:
          min_value: 0
          max_value: 1500
          ignore_out_of_range: true
    force_update: true
    unit_of_measurement: "RPM"
    accuracy_decimals: 0
    icon: mdi:fan

  - platform: pulse_counter
    id: rack_fan_tach
    name: "Rack Fan RPM"
    pin:
      number: GPIO35
      mode:
        input: true
        pullup: false
    count_mode:
      rising_edge: INCREMENT
      falling_edge: DISABLE
    update_interval: 1s
    filters:
      - multiply: 0.5
      - throttle_with_priority:
          timeout: 3s
          value:
            - nan
            - 0
      - clamp:
          min_value: 0
          max_value: 7000
          ignore_out_of_range: true
    force_update: true
    unit_of_measurement: "RPM"
    accuracy_decimals: 0
    icon: mdi:fan

  - platform: pulse_counter
    id: cabinet_fan2_tach
    name: "Cabinet Fan 2 RPM"
    pin:
      number: GPIO33
      mode:
        input: true
        pullup: false
    count_mode:
      rising_edge: INCREMENT
      falling_edge: DISABLE
    update_interval: 1s
    filters:
      - multiply: 0.5
      - throttle_with_priority:
          timeout: 3s
          value:
            - nan
            - 0
      - clamp:
          min_value: 0
          max_value: 1500
          ignore_out_of_range: true
    force_update: true
    unit_of_measurement: "RPM"
    accuracy_decimals: 0
    icon: mdi:fan

  - platform: pulse_counter
    id: rack_fan2_tach
    name: "Rack Fan 2 RPM"
    pin:
      number: GPIO36
      mode:
        input: true
        pullup: false
    count_mode:
      rising_edge: INCREMENT
      falling_edge: DISABLE
    update_interval: 1s
    filters:
      - multiply: 0.5
      - throttle_with_priority:
          timeout: 3s
          value:
            - nan
            - 0
      - clamp:
          min_value: 0
          max_value: 7000
          ignore_out_of_range: true
    force_update: true
    unit_of_measurement: "RPM"
    accuracy_decimals: 0
    icon: mdi:fan

  - platform: template
    id: cabinet_fan_runtime_sensor
    name: "Cabinet Fan Runtime Hours"
    lambda: |-
      return id(cabinet_fan_runtime_hours);
    update_interval: 60s
    unit_of_measurement: "h"
    accuracy_decimals: 1
    icon: mdi:clock-outline
    entity_category: "diagnostic"

  - platform: template
    id: rack_fan_runtime_sensor
    name: "Rack Fan Runtime Hours"
    lambda: |-
      return id(rack_fan_runtime_hours);
    update_interval: 60s
    unit_of_measurement: "h"
    accuracy_decimals: 1
    icon: mdi:clock-outline
    entity_category: "diagnostic"

script:
  - id: cabinet_fan_safe_start
    mode: restart
    parameters:
      speed: int
    then:
      - lambda: |-
          id(cabinet_fan_target_speed) = speed;
          id(cabinet_fan_spin_up_active) = true;
      - fan.turn_on:
          id: cabinet_fan
          speed: 10
      - logger.log:
          format: "Cabinet fan starting with spin-up sequence, target: %d%%"
          args: [ 'speed * 10' ]
      - delay: 3s
      - lambda: |-
          if (id(cabinet_fan_spin_up_active)) {
            id(cabinet_fan_spin_up_active) = false;
            auto call = id(cabinet_fan).make_call();
            call.set_speed(id(cabinet_fan_target_speed));
            call.perform();
          }
      - logger.log:
          format: "Cabinet fan spin-up complete, running at %d%%"
          args: [ 'id(cabinet_fan_target_speed) * 10' ]

  - id: download_fan_curves
    mode: restart
    then:
      - lambda: |-
          std::string url = id(fan_curves_url).state;
          ESP_LOGI("fan_curves", "Starting download from URL: %s", url.c_str());
      - http_request.get:
          url: !lambda |-
            return ((std::string) id(fan_curves_url).state).c_str();
          request_headers:
            Content-Type: application/json
          capture_response: true
          on_response:
            then:
              - if:
                  condition:
                    lambda: return response->status_code == 200;
                  then:
                    - logger.log:
                        format: "Fan curves downloaded successfully, content length: %d bytes"
                        args: [ 'body.length()' ]
                    - script.execute:
                        id: parse_fan_curves
                        json_content: !lambda |-
                          return body;
                  else:
                    - logger.log:
                        format: "Failed to download fan curves - HTTP status: %d, message: %s"
                        args: [ 'response->status_code', 'body.c_str()' ]

  - id: parse_fan_curves
    mode: restart
    parameters:
      json_content: string
    then:
      - lambda: |-
          ESP_LOGI("fan_curves", "Parsing JSON content, length: %d bytes", json_content.length());
          
          json::parse_json(json_content, [](JsonObject root) -> bool {
            if (root["curves"]) {
              ESP_LOGI("fan_curves", "Found curves object in JSON");
              
              // Parse cabinet_fan curve
              if (root["curves"]["cabinet_fan"]) {
                ESP_LOGI("fan_curves", "Found cabinet_fan curve configuration");
                JsonObject cabinet_curve = root["curves"]["cabinet_fan"];
                
                if (cabinet_curve["name"]) {
                  ESP_LOGI("fan_curves", "Cabinet fan curve name: %s", cabinet_curve["name"].as<const char*>());
                }
                
                if (cabinet_curve["points"]) {
                  JsonArray points = cabinet_curve["points"];
                  ESP_LOGI("fan_curves", "Cabinet fan curve has %d temperature points", points.size());
                  
                  // Clear existing curve data
                  id(cabinet_fan_temps).clear();
                  id(cabinet_fan_speeds).clear();
                  
                  // Store new curve points in vectors
                  for (JsonObject point : points) {
                    float temp = point["temp"];
                    int speed = point["speed"];
                    ESP_LOGI("fan_curves", "  Point: %.1f°C -> %d0%% speed", temp, speed);
                    
                    id(cabinet_fan_temps).push_back(temp);
                    id(cabinet_fan_speeds).push_back(speed);
                  }
                  
                  id(cabinet_curve_loaded) = true;
                  ESP_LOGI("fan_curves", "Cabinet fan curve loaded with %d points", id(cabinet_fan_temps).size());
                }
              }
              
              // Parse rack_fan curve
              if (root["curves"]["rack_fan"]) {
                ESP_LOGI("fan_curves", "Found rack_fan curve configuration");
                JsonObject rack_curve = root["curves"]["rack_fan"];
                
                if (rack_curve["name"]) {
                  ESP_LOGI("fan_curves", "Rack fan curve name: %s", rack_curve["name"].as<const char*>());
                }
                
                if (rack_curve["points"]) {
                  JsonArray points = rack_curve["points"];
                  ESP_LOGI("fan_curves", "Rack fan curve has %d temperature points", points.size());
                  
                  // Clear existing curve data
                  id(rack_fan_temps).clear();
                  id(rack_fan_speeds).clear();
                  
                  // Store new curve points in vectors
                  for (JsonObject point : points) {
                    float temp = point["temp"];
                    int speed = point["speed"];
                    ESP_LOGI("fan_curves", "  Point: %.1f°C -> %d0%% speed", temp, speed);
                    
                    id(rack_fan_temps).push_back(temp);
                    id(rack_fan_speeds).push_back(speed);
                  }
                  
                  id(rack_curve_loaded) = true;
                  ESP_LOGI("fan_curves", "Rack fan curve loaded with %d points", id(rack_fan_temps).size());
                }
              }
              
              if (root["version"]) {
                ESP_LOGI("fan_curves", "JSON version: %s", root["version"].as<const char*>());
              }
              
              ESP_LOGI("fan_curves", "Fan curves parsed and stored in vectors successfully");
              id(fan_curves_downloaded) = true;
              return true;
            } else {
              ESP_LOGI("fan_curves", "No 'curves' key found in JSON!");
              return false;
            }
          });

button:
  - platform: restart
    id: restart_button
    name: Restart

  - platform: safe_mode
    id: safe_mode_button
    name: Safe Mode

  - platform: factory_reset
    id: factory_reset_button
    name: Factory Reset

  - platform: template
    id: reset_fan_runtime
    name: "Reset Fan Runtime"
    icon: mdi:counter
    entity_category: "config"
    on_press:
      then:
        - lambda: |-
            id(cabinet_fan_runtime_hours) = 0.0;
            id(rack_fan_runtime_hours) = 0.0;
        - logger.log: "Fan runtime counter reset to 0 hours"
        - component.update: cabinet_fan_runtime_sensor
        - component.update: rack_fan_runtime_sensor

  - platform: template
    id: check_for_updates
    name: "Check for Updates"
    icon: mdi:update
    entity_category: "config"
    on_press:
      then:
        - component.update: update_http_request

  - platform: template
    id: download_curves_button
    name: "Download Fan Curves"
    icon: mdi:download
    entity_category: "config"
    on_press:
      then:
        - lambda: id(fan_curves_downloaded) = false;
        - script.execute: download_fan_curves

number:
  - platform: template
    id: failure_detection_after
    name: "Failure Detection After"
    optimistic: true
    min_value: 5
    max_value: 300
    step: 5
    unit_of_measurement: "s"
    icon: "mdi:timer-alert"
    entity_category: "config"
    restore_value: true
    initial_value: 30
    on_value:
      then:
        - logger.log:
            format: "Failure detection time changed to %.0f seconds"
            args: ['x']

text:
  - platform: template
    id: fan_curves_url
    name: "Fan Curves URL"
    optimistic: true
    min_length: 10
    max_length: 255
    mode: text
    icon: "mdi:web"
    entity_category: "config"
    restore_value: true
    initial_value: "https://raw.githubusercontent.com/DoYouHost/ServerCollingFanController/main/fan_curves/default.json"
    on_value:
      then:
        - logger.log:
            format: "Fan curves URL changed to: %s"
            args: ['x.c_str()']

switch:
  - platform: template
    id: auto_mode_switch
    name: "Auto Mode"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: "mdi:fan-auto"
    entity_category: config
    turn_on_action:
      - logger.log: "Auto mode enabled - fans will be controlled automatically"
    turn_off_action:
      - logger.log: "Auto mode disabled - manual fan control"

  - platform: template
    name: Beta Firmware
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: "mdi:test-tube"
    entity_category: config
    on_turn_on:
      - logger.log: "OTA updates set to use Beta firmware"
      - lambda: id(update_http_request).set_source_url("$BETA_MANIFEST_URL");
      - component.update: update_http_request
    on_turn_off:
      - logger.log: "OTA updates set to use Production firmware"
      - lambda: id(update_http_request).set_source_url("$PROD_MANIFEST_URL");
      - component.update: update_http_request

power_supply:
  - id: power_supply_fan
    pin:
      pcf8574: pcf8574_hub
      number: 1
      mode:
        output: true
      inverted: false
    enable_time: 20ms
    keep_on_time: 20ms

output:
  - platform: ledc
    id: cabinet_fan_output
    pin: GPIO5
    frequency: 19531
    min_power: 0.75
    zero_means_zero: true

  - platform: ledc
    id: rack_fan_output
    pin: GPIO17
    frequency: 19531
    min_power: 0.0
    zero_means_zero: true
    power_supply: power_supply_fan

  - platform: gpio
    id: error_led_output
    pin:
      pcf8574: pcf8574_hub
      number: 2
      mode:
        output: true
      inverted: true

fan:
  - platform: speed
    id: cabinet_fan
    output: cabinet_fan_output
    name: "Cabinet Fan"
    restore_mode: RESTORE_DEFAULT_OFF
    speed_count: 10
    on_turn_on:
      then:
        - lambda: |-
            int target_speed = id(cabinet_fan).speed > 0 ? id(cabinet_fan).speed : 1;
            id(cabinet_fan_safe_start)->execute(target_speed);
    on_speed_set:
      then:
        - lambda: |-
            if (!id(cabinet_fan_spin_up_active)) {
              id(cabinet_fan_target_speed) = x;
            }

  - platform: speed
    id: rack_fan
    output: rack_fan_output
    name: "Rack Fan"
    restore_mode: RESTORE_DEFAULT_OFF
    speed_count: 10

light:
  - platform: binary
    id: error_led
    internal: true
    output: error_led_output
    restore_mode: ALWAYS_OFF
    effects:
      - strobe:
          name: "Error Strobe"
          colors:
            - state: True
              brightness: 100%
              duration: 200ms
            - state: False
              brightness: 0%
              duration: 200ms

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    id: my_display
    update_interval: 3s
    pages:
      - id: normal_page
        lambda: |-
          // Line 1: Headers (0-12px)
          it.print(0, 0, id(font2), "CAB");
          it.print(64, 0, id(font2), "RACK");

          // Line 2: Fan 1 RPM (13-25px)
          it.printf(0, 13, id(font2), "%4.0f", id(cabinet_fan_tach).state);
          it.print(32, 13, id(font3), "RPM");
          it.printf(64, 13, id(font2), "%4.0f", id(rack_fan_tach).state);
          it.print(96, 13, id(font3), "RPM");

          // Line 3: Fan 2 RPM (26-38px)
          it.printf(0, 26, id(font2), "%4.0f", id(cabinet_fan2_tach).state);
          it.print(32, 26, id(font3), "RPM");
          it.printf(64, 26, id(font2), "%4.0f", id(rack_fan2_tach).state);
          it.print(96, 26, id(font3), "RPM");

          // Line 4: PWM percentages (39-51px) - show 0% if fan is off
          float cabinet_pwm = id(cabinet_fan).state ? id(cabinet_fan).speed * 10.0 : 0.0;
          float rack_pwm = id(rack_fan).state ? id(rack_fan).speed * 10.0 : 0.0;
          it.printf(0, 39, id(font2), "%3.0f%%", cabinet_pwm);
          it.print(32, 39, id(font3), "PWM");
          it.printf(64, 39, id(font2), "%3.0f%%", rack_pwm);
          it.print(96, 39, id(font3), "PWM");

          // Line 5: Temperatures (52-64px)
          it.printf(0, 52, id(font2), "%4.1f", id(cabinet_temp).state);
          it.print(32, 52, id(font3), "°C");
          it.printf(64, 52, id(font2), "%4.1f", id(rack_temp).state);
          it.print(96, 52, id(font3), "°C");

      - id: error_page
        lambda: |-
          // Line 1: Error header (0-16px)
          it.print(0, 0, id(font1), "FAN ERROR!");
          
          int line_y = 17; // Start position for error messages
          
          // Calculate required error cycles based on failure detection time
          int required_cycles = (int)(id(failure_detection_after).state / 5.0);
          if (required_cycles < 1) required_cycles = 1;
          
          // Check each fan and display only those with errors
          if (id(cabinet_fan_commanded) && id(cabinet_fan_error_count) >= required_cycles) {
            if (id(cabinet_fan_tach).state == 0) {
              it.print(0, line_y, id(font2), "Cabinet Fan 1 FAIL");
              line_y += 13;
            }
            if (id(cabinet_fan2_tach).state == 0) {
              it.print(0, line_y, id(font2), "Cabinet Fan 2 FAIL");
              line_y += 13;
            }
          }
          
          if (id(rack_fan_commanded) && id(rack_fan_error_count) >= required_cycles) {
            if (id(rack_fan_tach).state == 0) {
              it.print(0, line_y, id(font2), "Rack Fan 1 FAIL");
              line_y += 13;
            }
            if (id(rack_fan2_tach).state == 0) {
              it.print(0, line_y, id(font2), "Rack Fan 2 FAIL");
              line_y += 13;
            }
          }

font:
  - file: "gfonts://Source Code Pro"
    id: font1
    size: 16
  - file: "gfonts://Source Code Pro"
    id: font2
    size: 12
  - file: "gfonts://Source Code Pro"
    id: font3
    size: 10

status_led:
  pin:
    pcf8574: pcf8574_hub
    number: 0
    mode:
      output: true
    inverted: false
